

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Host &mdash; QuNetSim  documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.png"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Network" href="network.html" />
    <link rel="prev" title="Network Components" href="../components.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> QuNetSim
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../intro.html#what-is-qunetsim">What is QuNetSim?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intro.html#who-should-use-qunetsim">Who should use QuNetSim?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Install</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../install.html#via-pip">Via pip</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install.html#linux-mac-os-x">Linux / Mac OS X</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install.html#windows">Windows</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../quick_start.html">Quick Start Guide</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../design.html">Design Overview</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../components.html">Network Components</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Host</a></li>
<li class="toctree-l3"><a class="reference internal" href="network.html">Network</a></li>
<li class="toctree-l3"><a class="reference internal" href="protocols.html">Protocols</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../objects.html">Network Objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../objects/classical_storage.html">Classical Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="../objects/message.html">Message</a></li>
<li class="toctree-l3"><a class="reference internal" href="../objects/packet.html">Packet</a></li>
<li class="toctree-l3"><a class="reference internal" href="../objects/quantum_storage.html">Quantum Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="../objects/qubit.html">Qubit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../objects/routing_packet.html">Routing Packet</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../backends.html">Backends</a></li>
<li class="toctree-l2"><a class="reference internal" href="../backends.html#writing-your-own-backend">Writing your own Backend</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../examples/send_data.html">Send Data Qubits</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/send_epr.html">Send EPR Pairs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/chsh.html">CHSH Game</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/packet_sniffing.html">Eavesdropping on channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/quantum_money.html">Quantum Money with a Man-in-the-Middle Attack</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/entanglement_routing.html">Routing with Entanglement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/QKD.html">Quantum Key Distribution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/quantum_coin_flipping.html">Quantum Coin Flipping</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/anonymous_transfer.html">GHZ Based Anonymous Entanglement</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QuNetSim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../design.html">Design Overview</a> &raquo;</li>
        
          <li><a href="../components.html">Network Components</a> &raquo;</li>
        
      <li>Host</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/components/host.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="host">
<h1>Host<a class="headerlink" href="#host" title="Permalink to this headline">Â¶</a></h1>
<p>The Host component is analogous to a host, or node in a classical network. Hosts in QuNetSim act either as a routing
node that can relay packets through the network, or they can act as a node that runs a specific protocol. It is up
to the protocol developer to configure how the nodes behave. In most cases, once the network is established,
users will run specific protocols on the nodes. In the examples we see how to accomplish this.</p>
<p>One other feature of a host is that they can also sniff packets, or eavesdrop on channels to manipulate the payload
of the packet. For example, they can apply random noise to any qubit or change the classical messages that are routed
through them. We see an example of that in the examples section.</p>
<p>The most commonly used methods for Hosts are:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">add_connection(host_id)</span></code></dt><dd><ul>
<li><p>Add a classical and quantum connection to the host with id <em>host_id</em></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">get_classical(host_id,</span> <span class="pre">wait=N)</span></code></dt><dd><ul>
<li><p>Get a classical message from sender with host_id <em>host_id</em> and wait <em>N</em> seconds for it</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">get_data_qubit(host_id,</span> <span class="pre">wait=N)</span></code>:</dt><dd><ul>
<li><p>Get a data qubit from sender with host_id <em>host_id</em> and wait <em>N</em> seconds for it</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">get_data_qubits(host_id)</span></code>:</dt><dd><ul>
<li><p>Get all data qubits from sender with host_id <em>host_id</em></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">get_epr(host_id,</span> <span class="pre">q_id=q_id)</span></code>:</dt><dd><ul>
<li><p>Get EPR pair with qubit ID <em>q_id</em> from sender with host_id <em>host_id</em>. If <em>q_id=None</em> then get the first free EPR pair</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">get_epr_pairs(host_id)</span></code>:</dt><dd><ul>
<li><p>Get all EPR pairs established with host with host_id <em>host_id</em></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">send_classical(host_id,</span> <span class="pre">message,</span> <span class="pre">await_ack=&lt;bool&gt;)</span></code>:</dt><dd><ul>
<li><p>Send the classical message <em>message</em> to host with host_id <em>host_id</em>. Block until ACK arrives if <em>await_ack=True</em></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">send_key(host_id,</span> <span class="pre">key_size)</span></code>:</dt><dd><ul>
<li><p>Send a secret key via QKD of length <em>key_size</em> to host with ID <em>receiver_id</em>.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">send_qubit(host_id,</span> <span class="pre">qubit,</span> <span class="pre">await_ack=&lt;bool&gt;)</span></code>:</dt><dd><ul>
<li><p>Send qubit <em>qubit</em> to host with host_id <em>host_id</em>. Block until ACK arrives if <em>await_ack=True</em>.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">send_superdense(host_id,</span> <span class="pre">message,</span> <span class="pre">await_ack=&lt;bool&gt;)</span></code>:</dt><dd><ul>
<li><p>Send a message (one of â00â, â01â, â10â, or â11â) as a superdense message</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">send_teleport(host_id,</span> <span class="pre">qubit,</span> <span class="pre">await_ack=&lt;bool&gt;)</span></code>:</dt><dd><ul>
<li><p>Teleport qubit <em>qubit</em> to host with host_id <em>host_id</em>.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">send_epr(host_id,</span> <span class="pre">qubit_id=&lt;None&gt;,</span> <span class="pre">await_ack=&lt;bool&gt;)</span></code>:</dt><dd><ul>
<li><p>Creates a shared EPR pair with the host with host_id <em>host_id</em>.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">send_ghz([host_id_list],</span> <span class="pre">qubit_id=&lt;None&gt;,</span> <span class="pre">await_ack=&lt;bool&gt;)</span></code>:</dt><dd><ul>
<li><p>Creates a shared GHZ state with all hosts in the list [host_id_list].</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">shares_epr(host_id)</span></code>:</dt><dd><ul>
<li><p>Returns if the host shares entanglement already with host with host_id <em>host_id</em></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="code docutils literal notranslate"><span class="pre">run_protocol(protocol,</span> <span class="pre">protocol_params)</span></code>:</dt><dd><ul>
<li><p>Run the function <em>protocol</em> with the parameters <em>protocol_params</em>.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<span class="target" id="module-components.host"></span><dl class="class">
<dt id="components.host.Host">
<em class="property">class </em><code class="sig-prename descclassname">components.host.</code><code class="sig-name descname">Host</code><span class="sig-paren">(</span><em class="sig-param">host_id</em>, <em class="sig-param">backend=None</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Host object acting as either a router node or an application host node.</p>
<dl class="method">
<dt id="components.host.Host._get_message_w_seq_num">
<code class="sig-name descname">_get_message_w_seq_num</code><span class="sig-paren">(</span><em class="sig-param">sender_id</em>, <em class="sig-param">seq_num</em>, <em class="sig-param">wait=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host._get_message_w_seq_num" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get a message from a sender with a specific sequence number.
:param sender_id: The ID of the sender
:type sender_id: str
:param seq_num: The sequence number
:type seq_num: int
:param wait:
:type wait: int</p>
<p>Returns:</p>
</dd></dl>

<dl class="method">
<dt id="components.host.Host._get_sequence_number">
<code class="sig-name descname">_get_sequence_number</code><span class="sig-paren">(</span><em class="sig-param">host</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host._get_sequence_number" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get and set the next sequence number of connection with a receiver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>host</strong> (<em>str</em>) â The ID of the receiver</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The next sequence number of connection with a receiver.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(int)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host._log_ack">
<code class="sig-name descname">_log_ack</code><span class="sig-paren">(</span><em class="sig-param">protocol</em>, <em class="sig-param">receiver</em>, <em class="sig-param">seq</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host._log_ack" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Logs acknowledgement messages.
:param protocol: The protocol for the ACK
:type protocol: str
:param receiver: The sender of the ACK
:type receiver: str
:param seq: The sequence number of the packet
:type seq: int</p>
</dd></dl>

<dl class="method">
<dt id="components.host.Host._process_ack">
<code class="sig-name descname">_process_ack</code><span class="sig-paren">(</span><em class="sig-param">sender</em>, <em class="sig-param">seq_num</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host._process_ack" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Processes an ACK msg.</p>
</dd></dl>

<dl class="method">
<dt id="components.host.Host._process_packet">
<code class="sig-name descname">_process_packet</code><span class="sig-paren">(</span><em class="sig-param">packet</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host._process_packet" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Processes the received packet.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>packet</strong> (<a class="reference internal" href="../objects/packet.html#objects.packet.Packet" title="objects.packet.Packet"><em>Packet</em></a>) â The received packet</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host._process_queue">
<code class="sig-name descname">_process_queue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host._process_queue" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Runs a thread for processing the packets in the packet queue.</p>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.add_c_connection">
<code class="sig-name descname">add_c_connection</code><span class="sig-paren">(</span><em class="sig-param">receiver_id</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.add_c_connection" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Adds the classical connection to host with ID <em>receiver_id</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>receiver_id</strong> (<em>str</em>) â The ID of the host to connect with.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.add_c_connections">
<code class="sig-name descname">add_c_connections</code><span class="sig-paren">(</span><em class="sig-param">receiver_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.add_c_connections" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Adds the classical connections to host with ID <em>receiver_id</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>receiver_ids</strong> (<em>list</em>) â The IDs of the hosts to connect with.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.add_checksum">
<code class="sig-name descname">add_checksum</code><span class="sig-paren">(</span><em class="sig-param">qubits</em>, <em class="sig-param">size_per_qubit=2</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.add_checksum" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Generate a set of qubits that represent a quantum checksum for the set of qubits <em>qubits</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qubits</strong> â The set of qubits to encode</p></li>
<li><p><strong>size_per_qubit</strong> (<em>int</em>) â The size of the checksum per qubit (i.e. 1 qubit encoded into <em>size</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of qubits that are encoded for <em>qubits</em></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.add_connection">
<code class="sig-name descname">add_connection</code><span class="sig-paren">(</span><em class="sig-param">receiver_id</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.add_connection" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Adds the classical and quantum connection to host with ID <em>receiver_id</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>receiver_id</strong> (<em>str</em>) â The ID of the host to connect with.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.add_connections">
<code class="sig-name descname">add_connections</code><span class="sig-paren">(</span><em class="sig-param">receiver_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.add_connections" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Adds the classical and quantum connections to host with ID <em>receiver_id</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>receiver_ids</strong> (<em>list</em>) â A list of receiver IDs to connect with</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.add_data_qubit">
<code class="sig-name descname">add_data_qubit</code><span class="sig-paren">(</span><em class="sig-param">host_id</em>, <em class="sig-param">qubit</em>, <em class="sig-param">q_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.add_data_qubit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Adds the data qubit to the data qubit store of a host. If the qubit has an ID, adds the qubit with it,
otherwise generates an ID for the qubit and adds the qubit with that ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host_id</strong> (<em>str</em>) â The ID of the host to pair the qubit</p></li>
<li><p><strong>qubit</strong> (<a class="reference internal" href="../objects/qubit.html#objects.qubit.Qubit" title="objects.qubit.Qubit"><em>Qubit</em></a>) â The data Qubit to be added.</p></li>
<li><p><strong>q_id</strong> (<em>str</em>) â the ID to set the qubit ID to</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The qubit ID</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(string) <em>q_id</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.add_epr">
<code class="sig-name descname">add_epr</code><span class="sig-paren">(</span><em class="sig-param">host_id</em>, <em class="sig-param">qubit</em>, <em class="sig-param">q_id=None</em>, <em class="sig-param">blocked=False</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.add_epr" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Adds the EPR to the EPR store of a host. If the EPR has an ID, adds the EPR with it,
otherwise generates an ID for the EPR and adds the qubit with that ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host_id</strong> (<em>String</em>) â The ID of the host to pair the qubit</p></li>
<li><p><strong>qubit</strong> (<a class="reference internal" href="../objects/qubit.html#objects.qubit.Qubit" title="objects.qubit.Qubit"><em>Qubit</em></a>) â The data Qubit to be added.</p></li>
<li><p><strong>q_id</strong> (<em>str</em>) â The ID of the qubit to be added.</p></li>
<li><p><strong>blocked</strong> â If the qubit should be stored as blocked or not</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The qubit ID</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(string) <em>q_id</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.add_ghz_qubit">
<code class="sig-name descname">add_ghz_qubit</code><span class="sig-paren">(</span><em class="sig-param">host_id</em>, <em class="sig-param">qubit</em>, <em class="sig-param">q_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.add_ghz_qubit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Adds the GHZ qubit to the storage of the host. The host id corresponds
to the generator of the GHZ state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host_id</strong> (<em>str</em>) â The ID of the host to pair the qubit</p></li>
<li><p><strong>qubit</strong> (<a class="reference internal" href="../objects/qubit.html#objects.qubit.Qubit" title="objects.qubit.Qubit"><em>Qubit</em></a>) â The data Qubit to be added.</p></li>
<li><p><strong>q_id</strong> (<em>str</em>) â the ID to set the qubit ID to</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The qubit ID</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(string) <em>q_id</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.add_q_connection">
<code class="sig-name descname">add_q_connection</code><span class="sig-paren">(</span><em class="sig-param">receiver_id</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.add_q_connection" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Adds the quantum connection to host with ID <em>receiver_id</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>receiver_id</strong> (<em>str</em>) â The ID of the host to connect with.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.add_q_connections">
<code class="sig-name descname">add_q_connections</code><span class="sig-paren">(</span><em class="sig-param">receiver_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.add_q_connections" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Adds the quantum connection to host with ID <em>receiver_id</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>receiver_ids</strong> (<em>list</em>) â The IDs of the hosts to connect with.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.await_ack">
<code class="sig-name descname">await_ack</code><span class="sig-paren">(</span><em class="sig-param">sequence_number</em>, <em class="sig-param">sender</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.await_ack" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Block until an ACK for packet with sequence number arrives.
:param sequence_number: The sequence number to wait for.
:param sender: The sender of the ACK</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The status of the ACK</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.await_remaining_acks">
<code class="sig-name descname">await_remaining_acks</code><span class="sig-paren">(</span><em class="sig-param">sender</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.await_remaining_acks" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Awaits all remaining ACKs of one sender.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sender</strong> (<em>str</em>) â sender for which to wait for all acks.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.change_epr_qubit_id">
<code class="sig-name descname">change_epr_qubit_id</code><span class="sig-paren">(</span><em class="sig-param">host_id</em>, <em class="sig-param">new_id</em>, <em class="sig-param">old_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.change_epr_qubit_id" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Change an EPR pair ID to another. If <em>old_id</em> is set, then change that specific
EPR half, otherwise change the first unblocked EPR half to the <em>new_id</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host_id</strong> (<em>str</em>) â The partner ID of the EPR pair.</p></li>
<li><p><strong>new_id</strong> (<em>str</em>) â The new ID to change the qubit too</p></li>
<li><p><strong>old_id</strong> (<em>str</em>) â The old ID of the qubit</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Old if of the qubit which has been changed.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.classical">
<em class="property">property </em><code class="sig-name descname">classical</code><a class="headerlink" href="#components.host.Host.classical" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Gets the received classical messages sorted with the sequence number.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Sorted array of classical messages.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Array</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.classical_connections">
<em class="property">property </em><code class="sig-name descname">classical_connections</code><a class="headerlink" href="#components.host.Host.classical_connections" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Gets the classical connections of the host.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>classical connections</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.delay">
<em class="property">property </em><code class="sig-name descname">delay</code><a class="headerlink" href="#components.host.Host.delay" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the delay of the queue processor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The delay per tick for the queue processor.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.empty_classical">
<code class="sig-name descname">empty_classical</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.empty_classical" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Empty the classical message buffers.</p>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.get_classical">
<code class="sig-name descname">get_classical</code><span class="sig-paren">(</span><em class="sig-param">host_id</em>, <em class="sig-param">seq_num=-1</em>, <em class="sig-param">wait=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.get_classical" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the classical messages from partner host <em>host_id</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host_id</strong> (<em>str</em>) â The ID of the partner who sent the clasical messages</p></li>
<li><p><strong>seq_num</strong> (<em>int</em>) â The sequence number of the message</p></li>
<li><p><strong>wait</strong> (<em>float</em>) â How long in seconds to wait for the messages if none are set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of classical messages from Host with ID <em>host_id</em>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.get_connections">
<code class="sig-name descname">get_connections</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.get_connections" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get a list of the connections with the types.</p>
<p>Returns:</p>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.get_data_qubit">
<code class="sig-name descname">get_data_qubit</code><span class="sig-paren">(</span><em class="sig-param">host_id</em>, <em class="sig-param">q_id=None</em>, <em class="sig-param">wait=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.get_data_qubit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Gets the data qubit received from another host in the network. If qubit ID is specified,
qubit with that ID is returned, else, the last qubit received is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host_id</strong> (<em>str</em>) â The ID of the host that data qubit to be returned is received from.</p></li>
<li><p><strong>q_id</strong> (<em>str</em>) â The qubit ID of the data qubit to get.</p></li>
<li><p><strong>wait</strong> (<em>float</em>) â The amount of time to wait for the a qubit to arrive</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Qubit received from the host with <em>host_id</em> and <em>q_id</em>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="../objects/qubit.html#objects.qubit.Qubit" title="objects.qubit.Qubit">Qubit</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.get_data_qubits">
<code class="sig-name descname">get_data_qubits</code><span class="sig-paren">(</span><em class="sig-param">host_id</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.get_data_qubits" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the dictionary of data qubits stored, just for the information regarding which qubits are stored.
Does not remove the qubits from storage like <em>get_data_qubit</em> does.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>host_id</strong> (<em>int</em>) â The host id from which the data qubit have been received.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>If <em>host_id</em> is not set, then return the entire dictionary of data qubits.</dt><dd><p>Else If <em>host_id</em> is set, then return the data qubits for that particular host if there are any.
Return an empty list otherwise.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.get_epr">
<code class="sig-name descname">get_epr</code><span class="sig-paren">(</span><em class="sig-param">host_id</em>, <em class="sig-param">q_id=None</em>, <em class="sig-param">wait=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.get_epr" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Gets the EPR that is entangled with another host in the network. If qubit ID is specified,
EPR with that ID is returned, else, the last EPR added is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host_id</strong> (<em>str</em>) â The ID of the host that returned EPR is entangled to.</p></li>
<li><p><strong>q_id</strong> (<em>str</em>) â The qubit ID of the EPR to get.</p></li>
<li><p><strong>wait</strong> (<em>float</em>) â the amount of time to wait</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Qubit shared with the host with <em>host_id</em> and <em>q_id</em>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="../objects/qubit.html#objects.qubit.Qubit" title="objects.qubit.Qubit">Qubit</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.get_epr_pairs">
<code class="sig-name descname">get_epr_pairs</code><span class="sig-paren">(</span><em class="sig-param">host_id</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.get_epr_pairs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the dictionary of EPR pairs stored, just for the information regarding which qubits are stored.
Does not remove the qubits from storage like <em>get_epr_pair</em> does.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>host_id</strong> (<em>str</em>) â Get the EPR pairs established with host with <em>host_id</em></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>If <em>host_id</em> is not set, then return the entire dictionary of EPR pairs.</dt><dd><p>Else If <em>host_id</em> is set, then return the EPRs for that particular host if there are any.
Return an empty list otherwise.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.get_ghz">
<code class="sig-name descname">get_ghz</code><span class="sig-paren">(</span><em class="sig-param">host_id</em>, <em class="sig-param">q_id=None</em>, <em class="sig-param">wait=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.get_ghz" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Gets the GHZ qubit which has been created by the host with the host ID <em>host_id</em>.
It is not necessary to know with whom the states are shared.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>host_id</strong> (<em>str</em>) â The ID of the host that creates the GHZ state.</p></li>
<li><p><strong>q_id</strong> (<em>str</em>) â The qubit ID of the GHZ to get.</p></li>
<li><p><strong>wait</strong> (<em>float</em>) â the amount of time to wait</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Qubit shared with the host with <em>host_id</em> and <em>q_id</em>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="../objects/qubit.html#objects.qubit.Qubit" title="objects.qubit.Qubit">Qubit</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.get_next_classical">
<code class="sig-name descname">get_next_classical</code><span class="sig-paren">(</span><em class="sig-param">sender_id</em>, <em class="sig-param">wait=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.get_next_classical" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Gets the next classical message available from a sender.
If wait is -1 (default), it is waited till a message arrives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sender_id</strong> (<em>str</em>) â ID of the sender from the returned message.</p></li>
<li><p><strong>wait</strong> (<em>int</em>) â waiting time, default forever.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.get_next_classical_message">
<code class="sig-name descname">get_next_classical_message</code><span class="sig-paren">(</span><em class="sig-param">receive_from_id</em>, <em class="sig-param">buffer</em>, <em class="sig-param">sequence_nr</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.get_next_classical_message" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>receive_from_id</strong> â </p></li>
<li><p><strong>buffer</strong> â </p></li>
<li><p><strong>sequence_nr</strong> â </p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.get_sequence_number">
<code class="sig-name descname">get_sequence_number</code><span class="sig-paren">(</span><em class="sig-param">host</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.get_sequence_number" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get and set the next sequence number of connection with a receiver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>host</strong> (<em>str</em>) â The ID of the receiver</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The next sequence number of connection with a receiver.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(int)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.get_sequence_number_receiver">
<code class="sig-name descname">get_sequence_number_receiver</code><span class="sig-paren">(</span><em class="sig-param">host</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.get_sequence_number_receiver" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>host</strong> â </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.host_id">
<em class="property">property </em><code class="sig-name descname">host_id</code><a class="headerlink" href="#components.host.Host.host_id" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the <em>host_id</em> of the host.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The host ID of the host.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(str)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.is_idle">
<code class="sig-name descname">is_idle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.is_idle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns if the host has packets to process or is idle.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>If the host is idle or not.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(boolean)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.max_ack_wait">
<em class="property">property </em><code class="sig-name descname">max_ack_wait</code><a class="headerlink" href="#components.host.Host.max_ack_wait" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the maximum amount of time to wait for an ACK</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The maximum amount of time to wait for an ACK</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(float)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.quantum_connections">
<em class="property">property </em><code class="sig-name descname">quantum_connections</code><a class="headerlink" href="#components.host.Host.quantum_connections" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the quantum connections for the host.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The quantum connections for the host.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(list)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.quantum_relay_sniffing_function">
<code class="sig-name descname">quantum_relay_sniffing_function</code><span class="sig-paren">(</span><em class="sig-param">sender</em>, <em class="sig-param">receiver</em>, <em class="sig-param">qubit</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.quantum_relay_sniffing_function" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calls the quantum relay sniffing function if one is set.</p>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.rec_packet">
<code class="sig-name descname">rec_packet</code><span class="sig-paren">(</span><em class="sig-param">packet</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.rec_packet" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Puts the packet into the packet queue of the host.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>packet</strong> â Received packet.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.remove_c_connection">
<code class="sig-name descname">remove_c_connection</code><span class="sig-paren">(</span><em class="sig-param">receiver_id</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.remove_c_connection" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>receiver_id</strong> â </p>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.remove_connection">
<code class="sig-name descname">remove_connection</code><span class="sig-paren">(</span><em class="sig-param">receiver_id</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.remove_connection" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Remove a classical and quantum connection from a host.
:param receiver_id: The ID of the connection to remove
:type receiver_id: str</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a two element array of the status of the removals.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.run_protocol">
<code class="sig-name descname">run_protocol</code><span class="sig-paren">(</span><em class="sig-param">protocol</em>, <em class="sig-param">arguments=()</em>, <em class="sig-param">blocking=False</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.run_protocol" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Run the protocol <em>protocol</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>protocol</strong> (<em>function</em>) â The protocol that the host should run.</p></li>
<li><p><strong>arguments</strong> (<em>tuple</em>) â The set of (ordered) arguments for the protocol</p></li>
<li><p><strong>blocking</strong> (<em>bool</em>) â Wait for thread to stop before proceeding</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The thread the protocol is running on</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DaemonThread</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.send_ack">
<code class="sig-name descname">send_ack</code><span class="sig-paren">(</span><em class="sig-param">receiver</em>, <em class="sig-param">seq_number</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.send_ack" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Sends the classical message to the receiver host with
ID:receiver</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>receiver</strong> (<em>str</em>) â The ID of the host to send the message.</p></li>
<li><p><strong>seq_number</strong> (<em>int</em>) â Sequence number of the acknowleged packet.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.send_broadcast">
<code class="sig-name descname">send_broadcast</code><span class="sig-paren">(</span><em class="sig-param">message</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.send_broadcast" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Send a broadcast message to all of the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>message</strong> (<em>str</em>) â The message to broadcast</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.send_classical">
<code class="sig-name descname">send_classical</code><span class="sig-paren">(</span><em class="sig-param">receiver_id</em>, <em class="sig-param">message</em>, <em class="sig-param">await_ack=False</em>, <em class="sig-param">no_ack=False</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.send_classical" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Sends the classical message to the receiver host with
ID:receiver</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>receiver_id</strong> (<em>str</em>) â The ID of the host to send the message.</p></li>
<li><p><strong>message</strong> (<em>str</em>) â The classical message to send.</p></li>
<li><p><strong>await_ack</strong> (<em>bool</em>) â If sender should wait for an ACK.</p></li>
<li><p><strong>no_ack</strong> (<em>bool</em>) â If this message should not use any ACK and sequencing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If await_ack=True, return the status of the ACK</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.send_epr">
<code class="sig-name descname">send_epr</code><span class="sig-paren">(</span><em class="sig-param">receiver_id</em>, <em class="sig-param">q_id=None</em>, <em class="sig-param">await_ack=False</em>, <em class="sig-param">no_ack=False</em>, <em class="sig-param">block=False</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.send_epr" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Establish an EPR pair with the receiver and return the qubit
ID of pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>receiver_id</strong> (<em>str</em>) â The receiver ID</p></li>
<li><p><strong>q_id</strong> (<em>str</em>) â The ID of the qubit</p></li>
<li><p><strong>await_ack</strong> (<em>bool</em>) â If sender should wait for an ACK.</p></li>
<li><p><strong>no_ack</strong> (<em>bool</em>) â If this message should not use any ACK and sequencing.</p></li>
<li><p><strong>block</strong> (<em>bool</em>) â If the created EPR pair should be blocked or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If await_ack=True, return the ID of the EPR pair and the status of the ACK</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>string, boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.send_ghz">
<code class="sig-name descname">send_ghz</code><span class="sig-paren">(</span><em class="sig-param">receiver_list</em>, <em class="sig-param">q_id=None</em>, <em class="sig-param">await_ack=False</em>, <em class="sig-param">no_ack=False</em>, <em class="sig-param">distribute=False</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.send_ghz" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Share GHZ state with all receiver ids in the list. GHZ state is generated
locally.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>receiver_list</strong> (<em>list</em>) â A List of all Host IDs with which a GHZ state
should be shared.</p></li>
<li><p><strong>q_id</strong> (<em>str</em>) â The ID of the GHZ qubits</p></li>
<li><p><strong>await_ack</strong> (<em>bool</em>) â If the sender should await an ACK from all receivers</p></li>
<li><p><strong>no_ack</strong> (<em>bool</em>) â If this message should not use any ACK and sequencing.</p></li>
<li><p><strong>distribute</strong> (<em>bool</em>) â If the sender should keep part of the GHZ state, or just
distribute one</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>Qubit which belongs to the host and is part of the</dt><dd><p>GHZ state and ID which all Qubits will have.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Q_id, <a class="reference internal" href="../objects/qubit.html#objects.qubit.Qubit" title="objects.qubit.Qubit">Qubit</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.send_key">
<code class="sig-name descname">send_key</code><span class="sig-paren">(</span><em class="sig-param">receiver_id</em>, <em class="sig-param">key_size</em>, <em class="sig-param">await_ack=True</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.send_key" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Send a secret key via QKD of length <em>key_size</em> to host with ID <em>receiver_id</em>.
:param receiver_id:
:type receiver_id: str
:param key_size:
:type key_size: int
:param await_ack:
:type await_ack: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.send_qubit">
<code class="sig-name descname">send_qubit</code><span class="sig-paren">(</span><em class="sig-param">receiver_id</em>, <em class="sig-param">q</em>, <em class="sig-param">await_ack=False</em>, <em class="sig-param">no_ack=False</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.send_qubit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Send the qubit <em>q</em> to the receiver with ID <em>receiver_id</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>receiver_id</strong> (<em>str</em>) â The receiver ID to send the message to</p></li>
<li><p><strong>q</strong> (<a class="reference internal" href="../objects/qubit.html#objects.qubit.Qubit" title="objects.qubit.Qubit"><em>Qubit</em></a>) â The qubit to send</p></li>
<li><p><strong>await_ack</strong> (<em>bool</em>) â If sender should wait for an ACK.</p></li>
<li><p><strong>no_ack</strong> (<em>bool</em>) â If this message should not use any ACK and sequencing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If await_ack=True, return the ID of the qubit and the status of the ACK</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>string, boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.send_superdense">
<code class="sig-name descname">send_superdense</code><span class="sig-paren">(</span><em class="sig-param">receiver_id</em>, <em class="sig-param">message</em>, <em class="sig-param">await_ack=False</em>, <em class="sig-param">no_ack=False</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.send_superdense" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Send the two bit binary (i.e. â00â, â01â, â10â, â11) message via superdense
coding to the receiver with receiver ID <em>receiver_id</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>receiver_id</strong> (<em>str</em>) â The receiver ID to send the message to</p></li>
<li><p><strong>message</strong> (<em>str</em>) â The two bit binary message</p></li>
<li><p><strong>await_ack</strong> (<em>bool</em>) â If sender should wait for an ACK.</p></li>
<li><p><strong>no_ack</strong> (<em>bool</em>) â If this message should not use any ACK and sequencing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If await_ack=True, return the status of the ACK</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.send_teleport">
<code class="sig-name descname">send_teleport</code><span class="sig-paren">(</span><em class="sig-param">receiver_id</em>, <em class="sig-param">q</em>, <em class="sig-param">await_ack=False</em>, <em class="sig-param">no_ack=False</em>, <em class="sig-param">payload=None</em>, <em class="sig-param">generate_epr_if_none=True</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.send_teleport" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Teleports the qubit <em>q</em> with the receiver with host ID <em>receiver</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>receiver_id</strong> (<em>str</em>) â The ID of the host to establish the EPR pair with</p></li>
<li><p><strong>q</strong> (<a class="reference internal" href="../objects/qubit.html#objects.qubit.Qubit" title="objects.qubit.Qubit"><em>Qubit</em></a>) â The qubit to teleport</p></li>
<li><p><strong>await_ack</strong> (<em>bool</em>) â If sender should wait for an ACK.</p></li>
<li><p><strong>no_ack</strong> (<em>bool</em>) â If this message should not use any ACK and sequencing.</p></li>
<li><p><strong>payload</strong> â </p></li>
<li><p><strong>generate_epr_if_none</strong> â Generate an EPR pair with receiver if one doesnât exist</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If await_ack=True, return the status of the ACK</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.set_data_qubit_memory_limit">
<code class="sig-name descname">set_data_qubit_memory_limit</code><span class="sig-paren">(</span><em class="sig-param">limit</em>, <em class="sig-param">host_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.set_data_qubit_memory_limit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the limit to how many data qubits can be stored from host_id, or if host_id is not set,
use the limit for all connections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>limit</strong> (<em>int</em>) â The maximum number of qubits for the memory</p></li>
<li><p><strong>host_id</strong> (<em>str</em>) â (optional) The partner ID to set the limit with</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.set_epr_memory_limit">
<code class="sig-name descname">set_epr_memory_limit</code><span class="sig-paren">(</span><em class="sig-param">limit</em>, <em class="sig-param">host_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.set_epr_memory_limit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the limit to how many EPR pair halves can be stored from host_id, or if host_id is not set,
use the limit for all connections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>limit</strong> (<em>int</em>) â The maximum number of qubits for the memory</p></li>
<li><p><strong>host_id</strong> (<em>str</em>) â (optional) The partner ID to set the limit with</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.shares_epr">
<code class="sig-name descname">shares_epr</code><span class="sig-paren">(</span><em class="sig-param">receiver_id</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.shares_epr" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns boolean value dependent on if the host shares an EPR pair
with receiver with ID <em>receiver_id</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>receiver_id</strong> (<em>str</em>) â The receiver ID to check.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether the host shares an EPR pair with receiver with ID <em>receiver_id</em></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.sniff_full_packet">
<em class="property">property </em><code class="sig-name descname">sniff_full_packet</code><a class="headerlink" href="#components.host.Host.sniff_full_packet" title="Permalink to this definition">Â¶</a></dt>
<dd><p>If the eavesdropper should get the whole packet or just the
payload.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>If the eavesdropper should get the whole packet or just the</dt><dd><p>payload.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.start">
<code class="sig-name descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.start" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Starts the host.</p>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.stop">
<code class="sig-name descname">stop</code><span class="sig-paren">(</span><em class="sig-param">release_qubits=True</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host.Host.stop" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Stops the host. If release_qubit is true, clear the quantum memories.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>release_qubits</strong> (<em>boolean</em>) â If release_qubit is true, clear the quantum memories.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.storage_epr_limit">
<em class="property">property </em><code class="sig-name descname">storage_epr_limit</code><a class="headerlink" href="#components.host.Host.storage_epr_limit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the maximum number of qubits that can be held in EPR memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The maximum number of qubits that can be held in EPR memory.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(int)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="components.host.Host.storage_limit">
<em class="property">property </em><code class="sig-name descname">storage_limit</code><a class="headerlink" href="#components.host.Host.storage_limit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the maximum number of qubits that can be held in data qubit memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The maximum number of qubits that can be held in data qubit memory.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(int)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="components.host._get_qubit">
<code class="sig-prename descclassname">components.host.</code><code class="sig-name descname">_get_qubit</code><span class="sig-paren">(</span><em class="sig-param">store</em>, <em class="sig-param">host_id</em>, <em class="sig-param">q_id</em>, <em class="sig-param">purpose</em><span class="sig-paren">)</span><a class="headerlink" href="#components.host._get_qubit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Gets the data qubit received from another host in the network. If qubit ID is specified,
qubit with that ID is returned, else, the last qubit received is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> â The qubit storage to retrieve the qubit</p></li>
<li><p><strong>host_id</strong> (<em>str</em>) â The ID of the host that data qubit to be returned is received from.</p></li>
<li><p><strong>q_id</strong> (<em>str</em>) â The qubit ID of the data qubit to get.</p></li>
<li><p><strong>purpose</strong> (<em>str</em>) â The intended use of the qubit</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Qubit received from the host with <em>host_id</em> and <em>q_id</em>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="../objects/qubit.html#objects.qubit.Qubit" title="objects.qubit.Qubit">Qubit</a></p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Stephen DiAdamo, Janis NÃ¶tzel

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>